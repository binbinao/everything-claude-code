---
sidebar_position: 6
title: Performance Optimization
description: Master ECC performance analysis and optimization - Interactive Tutorial
---

import { CommandSimulator, StepByStep, CodePlayground, Quiz } from '@site/src/components/interactive'

# âš¡ Performance Optimization

Welcome to the advanced tutorials! In this course, you'll learn how to use ECC for comprehensive performance analysis and optimization â€” making your application fly like a rocket.

:::info Prerequisites
It's recommended to complete [TDD Masterclass](./tdd-masterclass) and [Custom Hooks](./custom-hooks) before starting this tutorial.
:::

## ğŸ® Try Performance Analysis Commands

ECC provides a powerful performance analysis toolkit. Try these commands:

<CommandSimulator 
  availableCommands={['/perf analyze', '/perf profile --cpu', '/perf bundle-size', '/perf lighthouse']}
  commandOutputs={{
    '/perf analyze': 'âš¡ Performance Analyzer started!\n\nğŸ“Š Global Performance Report:\n\nğŸ” Found 5 performance hotspots:\n  1. âŒ Unoptimized database queries (N+1 problem)\n     â†’ src/api/users.ts:42\n  2. âš ï¸ Large bundle size (1.2MB)\n     â†’ Suggest enabling Tree Shaking\n  3. âš ï¸ Frequently re-rendering component without React.memo\n     â†’ src/components/UserList.tsx\n  4. ğŸ’¡ Cacheable API responses\n     â†’ src/api/products.ts:18\n  5. ğŸ’¡ Images not using next/image\n     â†’ src/pages/home.tsx:55\n\nğŸ“ˆ Optimization potential: 40% faster load time',
    '/perf profile --cpu': 'âš¡ CPU Profiler started!\n\nğŸ”¥ CPU Flame Graph Analysis:\n\n  Top 5 time-consuming functions:\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ calculatePermissions   â”‚ 34.2% â”‚\n  â”‚ parseJSON              â”‚ 22.1% â”‚\n  â”‚ renderUserList         â”‚ 15.3% â”‚\n  â”‚ validateSchema         â”‚ 12.8% â”‚\n  â”‚ formatCurrency         â”‚  8.4% â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nğŸ’¡ Tip: calculatePermissions can be optimized with memoization\nğŸ’¡ Tip: parseJSON â€” consider using a streaming parser',
    '/perf bundle-size': 'ğŸ“¦ Bundle Size Analyzer\n\nğŸ“Š Current Bundle Composition:\n  Total: 1.2MB (gzipped: 380KB)\n\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n  â”‚ lodash          â”‚ 280KB â”‚ 23.3% â”‚\n  â”‚ moment          â”‚ 220KB â”‚ 18.3% â”‚\n  â”‚ react-dom       â”‚ 180KB â”‚ 15.0% â”‚\n  â”‚ chart.js        â”‚ 150KB â”‚ 12.5% â”‚\n  â”‚ your code       â”‚ 120KB â”‚ 10.0% â”‚\n  â”‚ others          â”‚ 250KB â”‚ 20.9% â”‚\n  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n\nğŸ”§ Optimization suggestions:\n  1. lodash â†’ lodash-es (Tree Shakeable)\n  2. moment â†’ dayjs (2KB alternative)\n  3. Estimated savings: 450KB (37.5%)',
    '/perf lighthouse': 'ğŸ—ï¸ Lighthouse Performance Audit\n\nğŸ“Š Scores:\n  Performance:    72 ğŸŸ¡\n  Accessibility:  95 ğŸŸ¢\n  Best Practices: 88 ğŸŸ¢\n  SEO:            92 ğŸŸ¢\n\nâ± Core Web Vitals:\n  LCP: 3.2s âŒ (target < 2.5s)\n  FID: 120ms ğŸŸ¡ (target < 100ms)\n  CLS: 0.05 ğŸŸ¢ (target < 0.1)\n\nğŸ”§ Top 3 improvements:\n  1. Lazy load below-the-fold images\n  2. Preconnect to critical third-party origins\n  3. Reduce unused JavaScript'
  }}
/>

## ğŸ“š Four-Step Performance Optimization

<StepByStep 
  title="Systematic Performance Optimization Process"
  steps={[
    {
      title: 'Step 1: Measure â€” Know Your Baseline',
      description: 'The golden rule of performance optimization: don\'t guess, use data. Like a doctor running tests before prescribing â€” you need to "diagnose" before you can "treat".',
      code: '# Step 1: Measure current performance\n\n# Run full performance audit\n/perf analyze\n\n# Profile CPU usage\n/perf profile --cpu\n\n# Analyze bundle size\n/perf bundle-size\n\n# Run Lighthouse audit\n/perf lighthouse\n\n# Record baseline metrics\n/perf baseline --save',
      tip: 'Always establish a performance baseline first â€” otherwise you can\'t quantify improvements!'
    },
    {
      title: 'Step 2: Analyze â€” Find the Bottleneck',
      description: 'Based on measurement data, identify the biggest performance bottlenecks. Follow the Pareto Principle (80/20 rule) â€” 20% of issues often cause 80% of performance loss.',
      code: '# Prioritize by impact\n# Example analysis results:\n\n# HIGH IMPACT (fix first)\n# 1. N+1 database queries â†’ batch loading\n# 2. Oversized bundle (lodash + moment)\n\n# MEDIUM IMPACT\n# 3. Missing React.memo on list items\n# 4. Uncached API responses\n\n# LOW IMPACT (fix later)\n# 5. Unoptimized images\n\n# Use ECC to create optimization plan\n/plan optimize top 3 performance issues',
      tip: 'Fix the highest-impact issues first. Don\'t waste time on low-impact items â€” that\'s premature optimization!'
    },
    {
      title: 'Step 3: Optimize â€” Apply Targeted Fixes',
      description: 'Implement specific optimization solutions for each bottleneck. ECC\'s TDD workflow ensures optimizations don\'t introduce new bugs.',
      code: '# Fix #1: N+1 Query â†’ DataLoader\n/tdd --feature="dataloader-optimization"\n\n# Fix #2: Bundle Size â†’ Tree Shaking\n# Replace lodash with lodash-es\nnpm uninstall lodash\nnpm install lodash-es\n# Replace moment with dayjs\nnpm uninstall moment\nnpm install dayjs\n\n# Fix #3: React Memoization\n/tdd --feature="memoize-user-list"\n\n# Verify each fix individually\n/perf analyze --compare=baseline',
      tip: 'Change only one thing at a time! Multiple simultaneous changes make it impossible to know which one worked.'
    },
    {
      title: 'Step 4: Verify â€” Continuous Monitoring',
      description: 'After optimization, re-measure and compare with the baseline. Set up a Performance Budget to prevent regression â€” like setting a spending limit.',
      code: '# Compare with baseline\n/perf analyze --compare=baseline\n\n# Set performance budget in CI\n# performance-budget.json\n{\n  "bundles": [\n    {\n      "name": "main",\n      "maxSize": "200KB"\n    }\n  ],\n  "lighthouse": {\n    "performance": 90,\n    "lcp": "2.5s",\n    "fid": "100ms",\n    "cls": 0.1\n  }\n}\n\n# Add to preCommit hooks\n/hooks add perf-budget --preCommit',
      tip: 'Performance budgets are the best way to prevent regression. Just like TDD prevents feature regression!'
    }
  ]}
/>

## ğŸ’» Hands-on: Optimize React Component Performance

Practice core React performance optimization techniques in the code playground:

<CodePlayground 
  title="React Performance Optimization"
  language="typescript"
  initialCode={`// Before: Unoptimized component
// Every parent re-render causes ALL items to re-render

import { useState, useMemo, useCallback, memo } from 'react'

// âŒ BEFORE: No memoization
function UserListBefore({ users, onSelect }) {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id} onClick={() => onSelect(user.id)}>
          {user.name} - {formatRole(user.role)}
        </li>
      ))}
    </ul>
  )
}

// âœ… AFTER: Optimized with memo + useCallback
const UserItem = memo(function UserItem({ user, onSelect }) {
  return (
    <li onClick={() => onSelect(user.id)}>
      {user.name} - {formatRole(user.role)}
    </li>
  )
})

function UserListAfter({ users, onSelect }) {
  // Memoize the callback to prevent unnecessary re-renders
  const handleSelect = useCallback((id: string) => {
    onSelect(id)
  }, [onSelect])

  // Memoize expensive computation
  const sortedUsers = useMemo(() => 
    [...users].sort((a, b) => a.name.localeCompare(b.name)),
    [users]
  )

  return (
    <ul>
      {sortedUsers.map(user => (
        <UserItem 
          key={user.id} 
          user={user} 
          onSelect={handleSelect} 
        />
      ))}
    </ul>
  )
}

// Helper function
function formatRole(role: string): string {
  return role.charAt(0).toUpperCase() + role.slice(1)
}

// Try it: Add virtualization for large lists
// Hint: Use react-window or @tanstack/virtual`}
/>

## â“ Knowledge Check

<Quiz 
  question="What should be the first step of performance optimization?"
  options={[
    'Immediately start rewriting slow code',
    'Upgrade to the latest framework version',
    'Measure current performance and establish a baseline',
    'Add more caching'
  ]}
  correctAnswer={2}
  explanation="The golden rule: measure first, optimize second. Without a baseline, you can't quantify improvements or know if you're optimizing in the right direction. It's like weighing yourself before starting a diet â€” otherwise, how would you know how much you've lost?"
/>

<Quiz 
  question="Which approach most effectively reduces JavaScript bundle size?"
  options={[
    'Minify all variable names',
    'Use Tree Shaking to remove unused code + replace with lightweight libraries',
    'Merge all code into a single file',
    'Remove code comments'
  ]}
  correctAnswer={1}
  explanation="Tree Shaking automatically removes unused exports, and combined with lightweight replacements (e.g., moment â†’ dayjs saves 218KB), it's the most effective way to reduce bundle size. Variable minification is just the final step of minification."
/>

<Quiz 
  question="When should you use React.memo?"
  options={[
    'Wrap every component with React.memo',
    'Only for components with stable props and expensive rendering',
    'Only for class components',
    'Only for the root component'
  ]}
  correctAnswer={1}
  explanation="React.memo is best for: (1) components whose props change less frequently than the parent renders, (2) components with expensive rendering logic. Overusing memo adds memory overhead and comparison cost. Remember: don't optimize prematurely â€” use Profiler to confirm bottlenecks first!"
/>

## ğŸ‰ Congratulations!

You've completed the Performance Optimization tutorial! You've mastered:

- âœ… Four-step optimization: Measure â†’ Analyze â†’ Optimize â†’ Verify
- âœ… ECC performance analysis toolkit
- âœ… Bundle size optimization strategies
- âœ… React component optimization (memo/useMemo/useCallback)
- âœ… Performance budgets and continuous monitoring

## ğŸ“– Next Steps

- [Security Best Practices](./security-best-practices) - Build secure applications
- [Enterprise Patterns](./enterprise-patterns) - Large-scale project architecture
- [Advanced Topics: Performance](/docs/advanced/performance) - Deep dive into performance
