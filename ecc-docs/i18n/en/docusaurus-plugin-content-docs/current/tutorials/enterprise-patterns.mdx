---
sidebar_position: 8
title: Enterprise Patterns
description: Large-scale project architecture and governance - Interactive Tutorial
---

import { CommandSimulator, StepByStep, CodePlayground, Quiz } from '@site/src/components/interactive'

# ğŸ¢ Enterprise Patterns

Welcome to the Enterprise Patterns tutorial! In this course, you'll learn how to use ECC to build scalable, maintainable large-scale project architectures â€” like building a skyscraper, the foundation determines the height.

:::info Prerequisites
It's recommended to complete all intermediate tutorials, especially [Multi-Agent Workflows](./multi-agent-workflow) and [Custom Hooks](./custom-hooks).
:::

## ğŸ® Try Enterprise-Level Commands

ECC provides specialized governance and architecture tools for large projects. Try these commands:

<CommandSimulator 
  availableCommands={['/architect analyze', '/plan monorepo-setup', '/architect boundaries', '/security + /perf + /code-review']}
  commandOutputs={{
    '/architect analyze': 'ğŸ—ï¸ Architect agent analyzing...\n\nğŸ“Š Project Architecture Report:\n\nğŸ“ Structure: Monorepo (Turborepo)\n  â”œâ”€â”€ apps/web        (Next.js frontend)\n  â”œâ”€â”€ apps/api        (Express backend)\n  â”œâ”€â”€ packages/ui     (Shared UI components)\n  â”œâ”€â”€ packages/shared (Shared types & utils)\n  â””â”€â”€ packages/config (Shared configuration)\n\nğŸ“ˆ Code Health:\n  Module Coupling: Medium ğŸŸ¡\n  Code Duplication: 8% ğŸŸ¢\n  Test Coverage: 72% ğŸŸ¡\n  Type Safety: 95% ğŸŸ¢\n\nâš ï¸ Architecture Risks:\n  1. apps/web imports apps/api internal modules directly\n  2. 3 circular dependencies detected\n  3. shared package is too large (needs splitting)',
    '/plan monorepo-setup': 'ğŸ¯ Planner creating Monorepo setup plan\n\nğŸ“‹ Implementation Plan (4 phases):\n\nPhase 1: Infrastructure (2h)\n  - Initialize Turborepo\n  - Configure workspaces\n  - Set up shared tsconfig\n\nPhase 2: Package Structure (3h)\n  - Create packages/ui\n  - Create packages/shared\n  - Create packages/config\n\nPhase 3: App Migration (4h)\n  - Migrate web application\n  - Migrate API service\n  - Update import paths\n\nPhase 4: CI/CD (2h)\n  - Configure incremental builds\n  - Set up caching strategy\n  - Configure parallel testing',
    '/architect boundaries': 'ğŸ—ï¸ Module Boundary Check\n\nğŸ“Š Dependency Analysis:\n\nâœ… Valid Dependencies:\n  apps/web â†’ packages/ui âœ…\n  apps/web â†’ packages/shared âœ…\n  apps/api â†’ packages/shared âœ…\n\nâŒ Violations (3):\n  1. apps/web â†’ apps/api/src/models âŒ\n     â†’ Should share types via packages/shared\n  2. packages/ui â†’ apps/web/src/hooks âŒ\n     â†’ UI package must not depend on app layer\n  3. packages/shared â†” packages/ui âŒ\n     â†’ Circular dependency!\n\nğŸ”§ Fix suggestions:\n  1. Extract shared types to packages/shared\n  2. Extract shared hooks to packages/hooks\n  3. Break circular dependency: split shared package',
    '/security + /perf + /code-review': 'ğŸ­ Parallel Review (3 agents working simultaneously)\n\nâ± Total time: 45s (parallel execution)\n\nğŸ“‹ Summary Report:\n\nğŸ”’ Security Review:\n  Score: 88/100 ğŸŸ¢\n  Found 2 MEDIUM risks\n\nâš¡ Performance Review:\n  Lighthouse: 91 ğŸŸ¢\n  Bundle: 380KB (Good)\n  Found 1 optimization suggestion\n\nğŸ“ Code Review:\n  Quality: A Grade ğŸŸ¢\n  Found 3 LOW-level improvement suggestions\n\nâœ… Overall: Ready for release'
  }}
/>

## ğŸ“š Four Pillars of Enterprise Architecture

<StepByStep 
  title="Building Enterprise-Grade Project Architecture"
  steps={[
    {
      title: 'Pillar 1: Monorepo Architecture',
      description: 'A Monorepo keeps multiple related projects in one repository. Like a large shopping mall â€” different stores (apps) share infrastructure (electricity, parking), operate independently but are managed together. Turborepo is the most popular Monorepo tool in the JavaScript ecosystem.',
      code: '# Project structure\nmy-enterprise-app/\nâ”œâ”€â”€ turbo.json              # Turborepo config\nâ”œâ”€â”€ package.json            # Root workspace config\nâ”œâ”€â”€ apps/\nâ”‚   â”œâ”€â”€ web/                # Next.js frontend\nâ”‚   â”‚   â”œâ”€â”€ package.json\nâ”‚   â”‚   â””â”€â”€ src/\nâ”‚   â”œâ”€â”€ api/                # Express backend\nâ”‚   â”‚   â”œâ”€â”€ package.json\nâ”‚   â”‚   â””â”€â”€ src/\nâ”‚   â””â”€â”€ admin/              # Admin dashboard\nâ”‚       â”œâ”€â”€ package.json\nâ”‚       â””â”€â”€ src/\nâ”œâ”€â”€ packages/\nâ”‚   â”œâ”€â”€ ui/                 # Shared UI components\nâ”‚   â”œâ”€â”€ shared/             # Shared types & utils\nâ”‚   â”œâ”€â”€ config/             # Shared configs\nâ”‚   â””â”€â”€ hooks/              # Shared React hooks\nâ””â”€â”€ tooling/\n    â”œâ”€â”€ eslint-config/      # Shared ESLint rules\n    â”œâ”€â”€ tsconfig/           # Shared TypeScript config\n    â””â”€â”€ testing/            # Shared test utilities',
      tip: 'Turborepo\'s remote cache can speed up CI builds by 10x!'
    },
    {
      title: 'Pillar 2: Module Boundaries & Dependency Governance',
      description: 'The biggest enemy of large projects is "spaghetti" dependencies. Module boundaries are like city zoning â€” residential, commercial, and industrial zones each have rules and can\'t be built randomly.',
      code: '// turbo.json - Define pipeline dependencies\n{\n  "$schema": "https://turbo.build/schema.json",\n  "pipeline": {\n    "build": {\n      "dependsOn": ["^build"],  // Build dependencies first\n      "outputs": ["dist/**", ".next/**"]\n    },\n    "test": {\n      "dependsOn": ["build"]\n    },\n    "lint": {\n      "outputs": []\n    }\n  }\n}\n\n// Enforce module boundaries\n// packages/ui/package.json\n{\n  "name": "@myapp/ui",\n  "dependencies": {\n    "@myapp/shared": "workspace:*"  // âœ… Allowed\n    // "@myapp/api": âŒ NOT allowed!\n  }\n}\n\n// Use ECC to enforce boundaries\n// /architect boundaries --strict',
      tip: 'Convention: packages/ can only depend on other packages/, never on apps/. apps/ can depend on packages/.'
    },
    {
      title: 'Pillar 3: Shared Component Library & Design System',
      description: 'UI consistency in enterprise projects relies on shared component libraries. Like franchise brand decoration standards â€” regardless of the location, users get a consistent experience.',
      code: '// packages/ui/src/Button/Button.tsx\nimport { cva, type VariantProps } from "class-variance-authority"\n\nconst buttonVariants = cva(\n  "inline-flex items-center justify-center rounded-md font-medium transition-colors",\n  {\n    variants: {\n      variant: {\n        primary: "bg-blue-600 text-white hover:bg-blue-700",\n        secondary: "bg-gray-100 text-gray-900 hover:bg-gray-200",\n        danger: "bg-red-600 text-white hover:bg-red-700",\n      },\n      size: {\n        sm: "h-8 px-3 text-sm",\n        md: "h-10 px-4 text-base",\n        lg: "h-12 px-6 text-lg",\n      },\n    },\n    defaultVariants: {\n      variant: "primary",\n      size: "md",\n    },\n  }\n)\n\ninterface ButtonProps \n  extends React.ButtonHTMLAttributes<HTMLButtonElement>,\n    VariantProps<typeof buttonVariants> {\n  isLoading?: boolean\n}\n\nexport function Button({ variant, size, isLoading, children, ...props }: ButtonProps) {\n  return (\n    <button className={buttonVariants({ variant, size })} disabled={isLoading} {...props}>\n      {isLoading ? <Spinner /> : children}\n    </button>\n  )\n}',
      tip: 'Use CVA (Class Variance Authority) to manage component variants â€” 10x more elegant than traditional className concatenation!'
    },
    {
      title: 'Pillar 4: CI/CD & Quality Gates',
      description: 'Enterprise project quality is guarded by automated pipelines. ECC\'s multi-agent parallel review is your "automated quality gate" â€” only code that passes all checks can merge to main.',
      code: '# .github/workflows/ci.yml\nname: CI Pipeline\n\non:\n  pull_request:\n    branches: [main]\n\njobs:\n  quality-gate:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        check: [lint, typecheck, test, security]\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n      - run: npm ci\n      \n      - name: Lint\n        if: matrix.check == \'lint\'\n        run: turbo lint\n        \n      - name: Type Check\n        if: matrix.check == \'typecheck\'\n        run: turbo typecheck\n        \n      - name: Test\n        if: matrix.check == \'test\'\n        run: turbo test -- --coverage\n        \n      - name: Security Audit\n        if: matrix.check == \'security\'\n        run: npm audit --audit-level=high\n\n  # All checks must pass\n  merge-gate:\n    needs: [quality-gate]\n    runs-on: ubuntu-latest\n    steps:\n      - run: echo "All quality gates passed! âœ…"',
      tip: 'GitHub Actions matrix strategy runs 4 checks in parallel, taking only the time of one!'
    }
  ]}
/>

## ğŸ’» Design Your Monorepo Architecture

Design a complete enterprise-level Monorepo configuration in the code playground:

<CodePlayground 
  title="Turborepo Configuration"
  language="json"
  initialCode={`{
  "$schema": "https://turbo.build/schema.json",
  "globalDependencies": [
    "**/.env.*local"
  ],
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**", "!.next/cache/**"]
    },
    "dev": {
      "cache": false,
      "persistent": true
    },
    "test": {
      "dependsOn": ["build"],
      "outputs": ["coverage/**"],
      "inputs": ["src/**/*.tsx", "src/**/*.ts", "test/**/*.ts"]
    },
    "test:e2e": {
      "dependsOn": ["build"],
      "outputs": ["playwright-report/**"]
    },
    "lint": {
      "dependsOn": ["^build"],
      "outputs": []
    },
    "typecheck": {
      "dependsOn": ["^build"],
      "outputs": []
    },
    "clean": {
      "cache": false
    }
  },
  "globalEnv": [
    "NODE_ENV",
    "CI"
  ],
  "remoteCache": {
    "enabled": true
  }
}`}
/>

## â“ Knowledge Check

<Quiz 
  question="What is the biggest advantage of Monorepo architecture?"
  options={[
    'Fewer Git repositories',
    'Code sharing, unified version management, and atomic commits',
    'Less disk space usage',
    'Faster build speed for individual packages'
  ]}
  correctAnswer={1}
  explanation="The core value of Monorepo lies in: (1) Cross-project code sharing (packages/), (2) Unified version management (one PR updates both frontend and backend), (3) Atomic commits (ensuring related changes are released together). Turborepo's incremental builds and remote cache also significantly accelerate CI."
/>

<Quiz 
  question="Which dependency relationship violates module boundary principles?"
  options={[
    'apps/web â†’ packages/ui',
    'apps/api â†’ packages/shared',
    'packages/ui â†’ apps/web/src/hooks',
    'packages/config â†’ no external dependencies'
  ]}
  correctAnswer={2}
  explanation="packages/ (lower-level packages) should never depend on apps/ (application layer) â€” this causes circular dependencies and tight coupling. The correct dependency direction is unidirectional: apps â†’ packages. If UI components need hooks, create an independent packages/hooks."
/>

<Quiz 
  question="What problem does Turborepo's Remote Cache solve?"
  options={[
    'Reducing node_modules size',
    'Encrypting build artifacts',
    'Sharing build cache between CI and team members to avoid redundant builds',
    'Auto-deploying to production'
  ]}
  correctAnswer={2}
  explanation="Remote cache lets team members and CI servers share build results. If a colleague has already built a package and the code hasn't changed, your machine uses the cached result instead of rebuilding. In large Monorepos, this can reduce CI time by over 80%."
/>

## ğŸ‰ Congratulations!

You've completed the Enterprise Patterns tutorial! You've mastered:

- âœ… Monorepo architecture design (Turborepo)
- âœ… Module boundaries and dependency governance
- âœ… Shared component library and design system
- âœ… CI/CD quality gate pipelines
- âœ… Multi-agent parallel review

## ğŸ“– Next Steps

- [Performance Optimization](./performance-optimization) - Optimize large-scale project performance
- [Security Best Practices](./security-best-practices) - Enterprise-level security practices
- [Advanced Topics: Performance](/docs/advanced/performance) - Deep dive into advanced topics
